{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5e4638bd1fb6a7cd585fb82d7076544ea7b6e7b3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CombinedRuleStorage.sol": "project/contracts/CombinedRuleStorage.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CombinedRuleStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IRuleLicense {\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function ruleExpiry(uint256 tokenId) external view returns (uint256);\r\n    function ruleTokenId(uint256 ruleId) external view returns (uint256);\r\n    function tokenRule(uint256 tokenId) external view returns (uint256);\r\n    function getRule(uint256 ruleId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32,\r\n            string memory,\r\n            address,\r\n            uint256,\r\n            uint16,\r\n            bool,\r\n            bool\r\n        );\r\n}\r\n\r\ncontract CombinedRuleStorage {\r\n    struct RuleRef {\r\n        address ruleNFT;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    struct CombinedRule {\r\n        address owner;\r\n        bytes32 ruleSetHash;\r\n        RuleRef[] rules;\r\n        uint64 version;\r\n        bool active;\r\n    }\r\n\r\n    enum RuleDirection {\r\n        INBOUND,\r\n        OUTBOUND\r\n    }\r\n\r\n    /* ===================== STORAGE ===================== */\r\n    mapping(address => mapping(uint256 => bool)) public usedRuleNFT;\r\n    uint256 public constant MAX_RULES = 10;\r\n\r\n    mapping(bytes32 => CombinedRule) private rules;\r\n\r\n    mapping(address => bytes32) public activeRuleOf;\r\n\r\n    mapping(address => mapping(RuleDirection => bytes32))\r\n        public activeRuleOfByDirection;\r\n\r\n    bytes32[] private allRuleSetHashes;\r\n    mapping(bytes32 => bool) private exists;\r\n\r\n    /* ===================== EVENTS ===================== */\r\n\r\n    event CombinedRuleRegistered(\r\n        bytes32 indexed ruleSetHash,\r\n        address indexed owner,\r\n        uint64 version\r\n    );\r\n\r\n    event CombinedRuleDeactivated(bytes32 indexed ruleSetHash);\r\n\r\n    event CombinedRuleOwnershipSynced(\r\n        bytes32 indexed ruleSetHash,\r\n        address indexed oldOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event CombinedRuleRegisteredWithDirection(\r\n        bytes32 indexed ruleSetHash,\r\n        address indexed owner,\r\n        RuleDirection indexed direction,\r\n        uint64 version\r\n    );\r\n\r\n    /* ===================== VIEW ===================== */\r\n\r\n    function _validateRuleNFT(\r\n        address ruleNFT,\r\n        uint256 tokenId,\r\n        address caller\r\n    ) internal view {\r\n\r\n        require(ruleNFT.code.length > 0, \"INVALID_RULE_NFT_CONTRACT\");\r\n\r\n        IRuleLicense nft = IRuleLicense(ruleNFT);\r\n\r\n        // ownership\r\n        require(\r\n            nft.ownerOf(tokenId) == caller,\r\n            \"NOT_RULE_NFT_OWNER\"\r\n        );\r\n\r\n        // expiry\r\n        uint256 expiry = nft.ruleExpiry(tokenId);\r\n        require(expiry == 0 || expiry >= block.timestamp, \"RULE_EXPIRED\");\r\n\r\n        // active + not deprecated\r\n        uint256 ruleId = nft.tokenRule(tokenId);\r\n        (, , , , , bool deprecated, bool active) =\r\n            nft.getRule(ruleId);\r\n\r\n        require(!deprecated, \"RULE_DEPRECATED\");\r\n        require(active, \"RULE_NOT_ACTIVE\");\r\n    }\r\n\r\n    function isActive(bytes32 ruleSetHash) external view returns (bool) {\r\n        return rules[ruleSetHash].active;\r\n    }\r\n\r\n    function listAllRuleSetHashes()\r\n        external\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return allRuleSetHashes;\r\n    }\r\n\r\n    function getActiveRuleOf(address owner)\r\n        external\r\n        view\r\n        returns (bytes32 ruleSetHash)\r\n    {\r\n        ruleSetHash = activeRuleOf[owner];\r\n        require(ruleSetHash != bytes32(0), \"NO_ACTIVE_RULE\");\r\n    }\r\n\r\n    function getActiveRuleOfByDirection(\r\n        address owner,\r\n        RuleDirection direction\r\n    ) external view returns (bytes32 ruleSetHash) {\r\n        ruleSetHash = activeRuleOfByDirection[owner][direction];\r\n        require(ruleSetHash != bytes32(0), \"NO_ACTIVE_RULE_FOR_DIRECTION\");\r\n    }\r\n\r\n    function getRuleByHash(\r\n        bytes32 ruleSetHash\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address owner,\r\n            RuleRef[] memory ruleRefs,\r\n            uint64 version\r\n        )\r\n    {\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        require(r.active, \"RULE_NOT_ACTIVE\");\r\n\r\n        return (r.owner, r.rules, r.version);\r\n    }\r\n\r\n    /* ===================== MUTATION ===================== */\r\n\r\n    function registerCombinedRule(\r\n        bytes32 ruleSetHash,\r\n        address[] calldata ruleNFTs,\r\n        uint256[] calldata tokenIds,\r\n        uint64 version\r\n    ) external {\r\n        _registerInternal(\r\n            ruleSetHash,\r\n            ruleNFTs,\r\n            tokenIds,\r\n            version,\r\n            true,\r\n            RuleDirection.OUTBOUND\r\n        );\r\n    }\r\n\r\n    function registerCombinedRuleForDirection(\r\n        bytes32 ruleSetHash,\r\n        RuleDirection direction,\r\n        address[] calldata ruleNFTs,\r\n        uint256[] calldata tokenIds,\r\n        uint64 version\r\n    ) external {\r\n        _registerInternal(\r\n            ruleSetHash,\r\n            ruleNFTs,\r\n            tokenIds,\r\n            version,\r\n            false,\r\n            direction\r\n        );\r\n    }\r\n\r\n    function _unlock(bytes32 hash) internal {\r\n        RuleRef[] storage refs = rules[hash].rules;\r\n\r\n        for (uint256 i = 0; i < refs.length; i++) {\r\n            usedRuleNFT[\r\n                refs[i].ruleNFT\r\n            ][\r\n                refs[i].tokenId\r\n            ] = false;\r\n        }\r\n    }\r\n\r\n    function _registerInternal(\r\n        bytes32 ruleSetHash,\r\n        address[] calldata ruleNFTs,\r\n        uint256[] calldata tokenIds,\r\n        uint64 version,\r\n        bool legacy,\r\n        RuleDirection direction\r\n    ) internal {\r\n        require(ruleSetHash != bytes32(0), \"INVALID_HASH\");\r\n        require(ruleNFTs.length > 0, \"EMPTY_RULE_SET\");\r\n        require(ruleNFTs.length <= MAX_RULES, \"MAX_10_RULES\");\r\n        require(ruleNFTs.length == tokenIds.length, \"ARRAY_LENGTH_MISMATCH\");\r\n\r\n        if (legacy) {\r\n            bytes32 prev = activeRuleOf[msg.sender];\r\n            if (prev != bytes32(0)) {\r\n                rules[prev].active = false;\r\n                emit CombinedRuleDeactivated(prev);\r\n            }\r\n        } else {\r\n            bytes32 prev = activeRuleOfByDirection[msg.sender][direction];\r\n            if (prev != bytes32(0)) {\r\n                rules[prev].active = false;\r\n                emit CombinedRuleDeactivated(prev);\r\n            }\r\n        }\r\n\r\n        if (!exists[ruleSetHash]) {\r\n            exists[ruleSetHash] = true;\r\n            allRuleSetHashes.push(ruleSetHash);\r\n        }\r\n\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        delete r.rules;\r\n\r\n        for (uint256 i = 0; i < ruleNFTs.length; i++) {\r\n            require(\r\n                !usedRuleNFT[ruleNFTs[i]][tokenIds[i]],\r\n                \"RULE_NFT_ALREADY_USED\"\r\n            );\r\n\r\n            usedRuleNFT[ruleNFTs[i]][tokenIds[i]] = true;\r\n            _validateRuleNFT(\r\n                ruleNFTs[i],\r\n                tokenIds[i],\r\n                msg.sender\r\n            );\r\n\r\n            r.rules.push(\r\n                RuleRef({\r\n                    ruleNFT: ruleNFTs[i],\r\n                    tokenId: tokenIds[i]\r\n                })\r\n            );\r\n        }\r\n\r\n        r.owner = msg.sender;\r\n        r.ruleSetHash = ruleSetHash;\r\n        r.version = version;\r\n        r.active = true;\r\n\r\n        if (legacy) {\r\n            activeRuleOf[msg.sender] = ruleSetHash;\r\n            emit CombinedRuleRegistered(ruleSetHash, msg.sender, version);\r\n        } else {\r\n            activeRuleOfByDirection[msg.sender][direction] = ruleSetHash;\r\n            emit CombinedRuleRegisteredWithDirection(\r\n                ruleSetHash,\r\n                msg.sender,\r\n                direction,\r\n                version\r\n            );\r\n        }\r\n    }\r\n\r\n        function deactivateMyCombinedRule() external {\r\n        bytes32 hash = activeRuleOf[msg.sender];\r\n        require(hash != bytes32(0), \"NO_ACTIVE_RULE\");\r\n\r\n        rules[hash].active = false;\r\n        activeRuleOf[msg.sender] = bytes32(0);\r\n\r\n        _unlock(hash);\r\n\r\n        emit CombinedRuleDeactivated(hash);\r\n    }\r\n\r\n    /**\r\n     * @notice Sync ownership if ALL rule NFTs moved to a new owner\r\n     * @dev Optional can be called by anyone\r\n     */\r\n    function syncOwner(bytes32 ruleSetHash) external {\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        require(r.active, \"RULE_NOT_ACTIVE\");\r\n        require(r.rules.length > 0, \"EMPTY_RULES\");\r\n\r\n        address newOwner =\r\n            IRuleLicense(r.rules[0].ruleNFT)\r\n                .ownerOf(r.rules[0].tokenId);\r\n\r\n        // verify all rule NFTs\r\n        for (uint256 i = 1; i < r.rules.length; i++) {\r\n            require(\r\n                IRuleLicense(r.rules[i].ruleNFT)\r\n                    .ownerOf(r.rules[i].tokenId) == newOwner,\r\n                \"RULE_NFT_OWNERSHIP_SPLIT\"\r\n            );\r\n        }\r\n\r\n        if (newOwner != r.owner) {\r\n            address old = r.owner;\r\n\r\n            if (activeRuleOf[old] == ruleSetHash) {\r\n                activeRuleOf[old] = bytes32(0);\r\n            }\r\n\r\n            r.owner = newOwner;\r\n            activeRuleOf[newOwner] = ruleSetHash;\r\n\r\n            emit CombinedRuleOwnershipSynced(\r\n                ruleSetHash,\r\n                old,\r\n                newOwner\r\n            );\r\n        }\r\n    }\r\n}\r\n"
      }
    }
  }
}