{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-4244d5b2556080626f0daf8cc46b06f1bfcaaa23",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CombinedRuleStorage.sol": "project/contracts/CombinedRuleStorage.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CombinedRuleStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IRuleLicense {\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function ruleExpiry(uint256 tokenId) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title CombinedRuleStorage\r\n * @notice Registry of ACTIVE combined ruleSets (multi-rule NFT composition)\r\n *\r\n * DESIGN INVARIANTS:\r\n * - Each owner may have ONLY ONE active combined rule at any time\r\n * - Registering a new combined rule automatically deactivates the previous one\r\n * - A combined rule references a SUBSET of rule NFTs owned by the caller\r\n * - Each combined rule may reference MULTIPLE rule NFTs (up to MAX_RULES)\r\n * - Ownership is enforced via ERC-721 rule license NFTs\r\n * - Rule evaluation logic (AND / OR / thresholds / windows) lives OFF-CHAIN\r\n * - On-chain state stores ONLY:\r\n *     - canonical ruleSetHash (bytes32)\r\n *     - rule NFT references (contract + tokenId)\r\n *     - owner + active state\r\n *\r\n * NON-GOALS:\r\n * - No rule logic execution on-chain\r\n * - No JSON / string / condition storage\r\n * - No per-transaction rule evaluation\r\n */\r\ncontract CombinedRuleStorage {\r\n    /* ===================== STRUCT ===================== */\r\n\r\n    struct RuleRef {\r\n        address ruleNFT;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    struct CombinedRule {\r\n        address owner;\r\n        bytes32 ruleSetHash;   \r\n        RuleRef[] rules;\r\n        uint64 version;\r\n        bool active;\r\n    }\r\n\r\n    /* ===================== STORAGE ===================== */\r\n\r\n    uint256 public constant MAX_RULES = 10;\r\n    mapping(bytes32 => CombinedRule) private rules;\r\n\r\n    mapping(address => bytes32) public activeRuleOf;\r\n\r\n    bytes32[] private allRuleSetHashes;\r\n    mapping(bytes32 => bool) private exists;\r\n\r\n    /* ===================== EVENTS ===================== */\r\n\r\n    event CombinedRuleRegistered(\r\n        bytes32 indexed ruleSetHash,\r\n        address indexed owner,\r\n        uint64 version\r\n    );\r\n\r\n    event CombinedRuleDeactivated(\r\n        bytes32 indexed ruleSetHash\r\n    );\r\n\r\n    event CombinedRuleOwnershipSynced(\r\n        bytes32 indexed ruleSetHash,\r\n        address indexed oldOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /* ===================== VIEW ===================== */\r\n\r\n    function isActive(bytes32 ruleSetHash) external view returns (bool) {\r\n        return rules[ruleSetHash].active;\r\n    }\r\n\r\n    function listAllRuleSetHashes()\r\n        external\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return allRuleSetHashes;\r\n    }\r\n\r\n    function getActiveRuleOf(address owner)\r\n        external\r\n        view\r\n        returns (bytes32 ruleSetHash)\r\n    {\r\n        ruleSetHash = activeRuleOf[owner];\r\n        require(ruleSetHash != bytes32(0), \"NO_ACTIVE_RULE\");\r\n    }\r\n\r\n    function getRuleByHash(\r\n        bytes32 ruleSetHash\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address owner,\r\n            RuleRef[] memory ruleRefs,\r\n            uint64 version\r\n        )\r\n    {\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        require(r.active, \"RULE_NOT_ACTIVE\");\r\n\r\n        return (r.owner, r.rules, r.version);\r\n    }\r\n\r\n    /* ===================== MUTATION ===================== */\r\n\r\n    /**\r\n     * @notice Register & activate a new combined rule\r\n     *\r\n     * @param ruleSetHash canonical hash of combined rule JSON\r\n     * @param ruleNFTs list of rule NFT contracts\r\n     * @param tokenIds list of rule NFT tokenIds\r\n     * @param version combined rule version\r\n     *\r\n     * REQUIREMENTS:\r\n     * - ruleNFTs.length == tokenIds.length\r\n     * - caller must own ALL rule NFTs\r\n     * - deactivates previous combined rule of caller\r\n     */\r\n    function registerCombinedRule(\r\n        bytes32 ruleSetHash,\r\n        address[] calldata ruleNFTs,\r\n        uint256[] calldata tokenIds,\r\n        uint64 version\r\n    ) external {\r\n        require(ruleSetHash != bytes32(0), \"INVALID_HASH\");\r\n        require(ruleNFTs.length > 0, \"EMPTY_RULE_SET\");\r\n        require(ruleNFTs.length <= MAX_RULES, \"MAX_10_RULES\");\r\n        require(ruleNFTs.length == tokenIds.length, \"ARRAY_LENGTH_MISMATCH\");\r\n\r\n        bytes32 prev = activeRuleOf[msg.sender];\r\n        if (prev != bytes32(0)) {\r\n            rules[prev].active = false;\r\n            emit CombinedRuleDeactivated(prev);\r\n        }\r\n\r\n        if (!exists[ruleSetHash]) {\r\n            exists[ruleSetHash] = true;\r\n            allRuleSetHashes.push(ruleSetHash);\r\n        }\r\n\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        delete r.rules;\r\n\r\n        for (uint256 i = 0; i < ruleNFTs.length; i++) {\r\n            require(\r\n                IRuleLicense(ruleNFTs[i]).ownerOf(tokenIds[i]) == msg.sender,\r\n                \"NOT_RULE_NFT_OWNER\"\r\n            );\r\n\r\n            r.rules.push(\r\n                RuleRef({\r\n                    ruleNFT: ruleNFTs[i],\r\n                    tokenId: tokenIds[i]\r\n                })\r\n            );\r\n        }\r\n\r\n        r.owner = msg.sender;\r\n        r.ruleSetHash = ruleSetHash;\r\n        r.version = version;\r\n        r.active = true;\r\n\r\n        activeRuleOf[msg.sender] = ruleSetHash;\r\n\r\n        emit CombinedRuleRegistered(ruleSetHash, msg.sender, version);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Deactivate caller's active combined rule\r\n     */\r\n    function deactivateMyCombinedRule() external {\r\n        bytes32 hash = activeRuleOf[msg.sender];\r\n        require(hash != bytes32(0), \"NO_ACTIVE_RULE\");\r\n\r\n        rules[hash].active = false;\r\n        activeRuleOf[msg.sender] = bytes32(0);\r\n\r\n        emit CombinedRuleDeactivated(hash);\r\n    }\r\n\r\n    /**\r\n     * @notice Sync ownership if ALL rule NFTs moved to a new owner\r\n     * @dev Optional can be called by anyone\r\n     */\r\n    function syncOwner(bytes32 ruleSetHash) external {\r\n        CombinedRule storage r = rules[ruleSetHash];\r\n        require(r.active, \"RULE_NOT_ACTIVE\");\r\n\r\n        address newOwner =\r\n            IRuleLicense(r.rules[0].ruleNFT)\r\n                .ownerOf(r.rules[0].tokenId);\r\n\r\n        // verify all rule NFTs share same owner\r\n        for (uint256 i = 1; i < r.rules.length; i++) {\r\n            require(\r\n                IRuleLicense(r.rules[i].ruleNFT)\r\n                    .ownerOf(r.rules[i].tokenId) == newOwner,\r\n                \"RULE_NFT_OWNERSHIP_SPLIT\"\r\n            );\r\n        }\r\n\r\n        if (newOwner != r.owner) {\r\n            address old = r.owner;\r\n\r\n            if (activeRuleOf[old] == ruleSetHash) {\r\n                activeRuleOf[old] = bytes32(0);\r\n            }\r\n\r\n            r.owner = newOwner;\r\n            activeRuleOf[newOwner] = ruleSetHash;\r\n\r\n            emit CombinedRuleOwnershipSynced(\r\n                ruleSetHash,\r\n                old,\r\n                newOwner\r\n            );\r\n        }\r\n    }\r\n}\r\n"
      }
    }
  }
}